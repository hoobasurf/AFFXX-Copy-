<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<title>Authentique</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500&display=swap" rel="stylesheet">
<style>
* { box-sizing:border-box; margin:0; padding:0; }
html, body { height:100%; width:100%; font-family:'Orbitron',sans-serif; background:url('planete-romantique.jpg') no-repeat center center/cover; color:white; overflow:hidden; }
body::before { content:""; position:fixed; top:0; left:0; width:100%; height:100%; background: radial-gradient(circle at center, rgba(255,0,255,0.05), transparent 70%); z-index:1; pointer-events:none; }
.header { position: relative; z-index:2; padding:20px; }
#myProfile { z-index:3; position: relative; text-align:center; margin-top:10px; cursor:pointer; }
#myProfile img { width:100px; height:100px; border-radius:50%; border:3px solid #ff66cc; box-shadow:0 0 15px #ff66cc; object-fit:cover; }
#myProfile div { margin-top:8px; font-size:1.2em; color:#ff66cc; }
/* Carrousel */
.carousel-container { z-index:2; position: relative; width:100%; height:calc(100% - 180px); overflow:hidden; display:flex; align-items:center; }
.carousel { display:flex; overflow-x:auto; scroll-snap-type:x mandatory; -webkit-overflow-scrolling:touch; gap:40px; padding:40px; }
.carousel::-webkit-scrollbar { display:none; }
.card { scroll-snap-align:center; flex:0 0 150px; background:rgba(0,0,0,0.5); border-radius:16px; padding:15px; text-align:center; transition: transform .3s, box-shadow .3s; cursor:pointer; position:relative; }
.card img { width:90px; height:90px; border-radius:50%; object-fit:cover; margin-bottom:10px; border:3px solid; }
.girl img { border-color:#ff66cc; box-shadow:0 0 12px #ff66cc; }
.boy img { border-color:#9933ff; box-shadow:0 0 12px #9933ff; }
.name { font-size:1.1em; margin-bottom:5px; }
.btns { display:flex; justify-content:center; gap:8px; margin-top:6px; }
.btn-like, .btn-chat, .btn-fav { width:30px; height:30px; border-radius:50%; background-color:rgba(255,255,255,0.1); border:1px solid #ff66cc; color:#ff66cc; display:flex; align-items:center; justify-content:center; font-size:1em; cursor:pointer; transition: transform .2s, background-color .3s, color .3s; user-select:none; }
.btn-like:hover, .btn-chat:hover, .btn-fav:hover { transform: scale(1.2); }
.btn-like.active { background-color:#ff66cc; border-color:#ff66cc; color:white; box-shadow:0 0 12px #ff66cc; }
.btn-fav.active { background-color:#ffea00; border-color:#ffea00; color:#333; box-shadow:0 0 12px #ffea00; }
/* Favoris bouton bas */
#favorisBtn { position:fixed; bottom:20px; left:50%; transform:translateX(-50%); width:50px; height:50px; border-radius:50%; background-color:#ffea00; border:2px solid #ffcc00; display:flex; align-items:center; justify-content:center; font-size:1.2em; cursor:pointer; z-index:10; box-shadow:0 0 12px #ffea00; }
#miniProfilesContainer { position:fixed; top:100px; left:50px; z-index:9; pointer-events:none; }
/* Chaque mini-profil positionné en absolute et pointer-events auto pour permettre interactions */
.mini-profile { position:absolute; width:50px; height:50px; border-radius:50%; border:2px solid #ff66cc; cursor:grab; display:flex; align-items:center; justify-content:center; overflow:hidden; pointer-events:auto; background:rgba(0,0,0,0.2); transition: transform .12s; }
.mini-profile img { width:100%; height:100%; object-fit:cover; border-radius:50%; }
.close-mini { position:absolute; top:-6px; right:-6px; width:14px; height:14px; border-radius:50%; background:#ff66cc; color:white; font-size:10px; font-weight:bold; display:flex; align-items:center; justify-content:center; cursor:pointer; z-index:11; box-shadow:0 0 6px #ff66cc; }
/* légère animation d'apparition */
.mini-profile.show { transform: scale(1); opacity:1; }
.mini-profile.init { transform: scale(.6); opacity:0; transition: transform .15s, opacity .15s; }
</style>
</head>
<body>

<!-- MINI-PROFIL -->
<div id="myProfile">
  <img id="miniProfilePic" src="" alt="Mon profil">
  <div id="pseudoMini">Utilisateur</div>
</div>

<!-- Carrousel -->
<div class="carousel-container">
  <div class="carousel" id="carousel"></div>
</div>

<!-- Favoris bouton bas -->
<div id="favorisBtn" title="Favoris">⭐</div>

<!-- Mini-profiles draggable container -->
<div id="miniProfilesContainer"></div>

<script type="module">
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.2.1/firebase-auth.js";
import { getDatabase, ref, update, onDisconnect, onValue, push, set, remove } 
  from "https://www.gstatic.com/firebasejs/12.2.1/firebase-database.js";
import { app } from "./firebase.js";

const auth = getAuth(app);
const db = getDatabase(app);

const miniProfilePic = document.getElementById("miniProfilePic");
const pseudoMini = document.getElementById("pseudoMini");
const carousel = document.getElementById("carousel");
const miniProfilesContainer = document.getElementById("miniProfilesContainer");
const favorisBtn = document.getElementById("favorisBtn");

let favorisList = []; // favoris uid list (from Firebase)
const LOCAL_KEY = "authentique_miniProfiles_v1"; // localStorage key for mini profiles

// utilitaires localStorage pour mini-profiles
function loadLocalMiniProfiles() {
  try {
    const raw = localStorage.getItem(LOCAL_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch (e) { return []; }
}
function saveLocalMiniProfiles(list) {
  try { localStorage.setItem(LOCAL_KEY, JSON.stringify(list)); } catch(e){}
}
function addLocalMiniProfile(obj) {
  const arr = loadLocalMiniProfiles();
  arr.push(obj);
  saveLocalMiniProfiles(arr);
}
function removeLocalMiniProfilesByUid(uid) {
  let arr = loadLocalMiniProfiles();
  arr = arr.filter(x => x.uid !== uid);
  saveLocalMiniProfiles(arr);
}
function removeLocalMiniProfileById(id) {
  let arr = loadLocalMiniProfiles();
  arr = arr.filter(x => x.id !== id);
  saveLocalMiniProfiles(arr);
}

// crée un id simple
function makeId() {
  return 'mp_' + Math.random().toString(36).slice(2,10);
}

// restaure mini-profiles depuis localStorage
function restoreMiniProfiles() {
  const list = loadLocalMiniProfiles();
  list.forEach(item => {
    createMiniProfileElement(item, false);
  });
}

// crée l'élément DOM et le rend draggable
function createMiniProfileElement(data, saveLocal = true) {
  // data: { id, uid, img, left, top }
  const mini = document.createElement("div");
  mini.className = "mini-profile init";
  mini.dataset.id = data.id;
  mini.dataset.uid = data.uid;
  mini.style.left = (data.left || 0) + "px";
  mini.style.top = (data.top || 0) + "px";
  mini.innerHTML = `<img src="${data.img}"><div class="close-mini">×</div>`;
  miniProfilesContainer.appendChild(mini);

  // small timeout to trigger show class (animation)
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      mini.classList.remove("init");
      mini.classList.add("show");
    });
  });

  // pointer-based dragging (works for mouse & touch)
  let isDragging = false;
  let startX = 0, startY = 0, startLeft = 0, startTop = 0;

  function onPointerDown(e) {
    e.preventDefault();
    isDragging = true;
    mini.style.cursor = "grabbing";
    startX = e.clientX;
    startY = e.clientY;
    const rect = mini.getBoundingClientRect();
    startLeft = rect.left;
    startTop = rect.top;
    // capture pointer
    mini.setPointerCapture && mini.setPointerCapture(e.pointerId);
  }

  function onPointerMove(e) {
    if (!isDragging) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    let newLeft = startLeft + dx;
    let newTop = startTop + dy;
    // clamp inside viewport (optional)
    const maxLeft = window.innerWidth - mini.offsetWidth - 4;
    const maxTop = window.innerHeight - mini.offsetHeight - 4;
    if (newLeft < 0) newLeft = 0;
    if (newTop < 0) newTop = 0;
    if (newLeft > maxLeft) newLeft = maxLeft;
    if (newTop > maxTop) newTop = maxTop;
    mini.style.left = newLeft + "px";
    mini.style.top = newTop + "px";
  }

  function onPointerUp(e) {
    if (!isDragging) return;
    isDragging = false;
    mini.style.cursor = "grab";
    // save position to localStorage
    const id = mini.dataset.id;
    const left = parseInt(mini.style.left || 0, 10);
    const top = parseInt(mini.style.top || 0, 10);
    const arr = loadLocalMiniProfiles();
    const idx = arr.findIndex(x => x.id === id);
    if (idx !== -1) {
      arr[idx].left = left;
      arr[idx].top = top;
      saveLocalMiniProfiles(arr);
    }
    // release pointer
    try { mini.releasePointerCapture && mini.releasePointerCapture(e.pointerId); } catch(e){}
  }

  mini.addEventListener("pointerdown", onPointerDown);
  window.addEventListener("pointermove", onPointerMove);
  window.addEventListener("pointerup", onPointerUp);

  // croix pour supprimer mini-profile
  const closeBtn = mini.querySelector(".close-mini");
  closeBtn.addEventListener("click", (ev) => {
    ev.stopPropagation();
    const id = mini.dataset.id;
    mini.remove();
    removeLocalMiniProfileById(id);
  });

  if (saveLocal) {
    addLocalMiniProfile(data);
  }
}

// supprime mini-profiles DOM et local pour un uid donné
function removeMiniProfilesForUid(uid) {
  // remove from DOM
  const nodes = miniProfilesContainer.querySelectorAll(`.mini-profile`);
  nodes.forEach(n => {
    if (n.dataset.uid === uid) n.remove();
  });
  // remove from localStorage
  removeLocalMiniProfilesByUid(uid);
}

// charger favoris du user et conserver en mémoire
function watchUserFavoris(currentUid) {
  const favRef = ref(db, `users/${currentUid}/favoris`);
  onValue(favRef, snap => {
    favorisList = [];
    if (snap.exists()) {
      const favObj = snap.val();
      favorisList = Object.keys(favObj);
    }
    // après mise à jour, on peut mettre à jour l'état visuel des cards s'ils sont rendus
    updateCardsFavorisState();
  });
}

// helper pour update style des boutons fav dans carousel
function updateCardsFavorisState() {
  const cards = carousel.querySelectorAll(".card");
  cards.forEach(card => {
    const targetUid = card.dataset.uid;
    const favBtn = card.querySelector(".btn-fav");
    if (!favBtn) return;
    if (favorisList.includes(targetUid)) favBtn.classList.add("active");
    else favBtn.classList.remove("active");
  });
}

onAuthStateChanged(auth, async user => {
  if (!user) {
    alert("Vous devez être connecté !");
    window.location.href = "inscription.html";
    return;
  }

  const userRef = ref(db, "users/" + user.uid);

  await update(userRef, { online: true });
  onDisconnect(ref(db, "users/" + user.uid + "/online")).set(false);

  // affichage du mini-profil principal
  onValue(userRef, snap => {
    if (snap.exists()) {
      const data = snap.val();
      pseudoMini.textContent = data.pseudo || "Utilisateur";
      miniProfilePic.src = (data.photos && data.photos.length > 0)
        ? data.photos[0]
        : "https://i.pravatar.cc/150?img=12";
    }
  });

  // surveiller favoris du user
  watchUserFavoris(user.uid);

  // carrousel des utilisateurs connectés
  const allUsersRef = ref(db, "users");
  onValue(allUsersRef, snap => {
    carousel.innerHTML = "";
    if (!snap.exists()) return;
    const allUsers = snap.val();

    Object.entries(allUsers).forEach(([uid, u]) => {
      if (uid !== user.uid && u.online === true) {
        const card = document.createElement("div");
        card.className = "card " + (u.gender || "girl");
        card.dataset.uid = uid;
        card.innerHTML = `
          <img src="${u.photos && u.photos.length > 0 ? u.photos[0] : 'https://i.pravatar.cc/150?img=12'}" alt="${u.pseudo}">
          <div class="name">${u.pseudo || 'Utilisateur'}</div>
          <div class="btns">
            <div class="btn-chat" title="Chat">💬</div>
            <div class="btn-like" title="Like">💖</div>
            <div class="btn-fav" title="Favoris">⭐️</div>
          </div>
        `;
        carousel.appendChild(card);
      }
    });

    if (carousel.innerHTML.trim() === "") {
      const emptyMsg = document.createElement("div");
      emptyMsg.style.textAlign = "center";
      emptyMsg.style.width = "100%";
      emptyMsg.style.color = "#ff66cc";
      emptyMsg.textContent = "Aucun utilisateur en ligne pour le moment...";
      carousel.appendChild(emptyMsg);
    }

    // une fois les cards ajoutées, synchroniser l'état des favoris visuellement
    updateCardsFavorisState();
  });
});

// Gestion boutons carrousel
carousel.addEventListener("click", async (e) => {
  const card = e.target.closest(".card");
  if (!card) return;
  const targetUid = card.dataset.uid;
  const currentUser = auth.currentUser;
  if (!currentUser || !targetUid) return;

  // Clic sur image → page2.html
  if (e.target.tagName === "IMG") {
    window.location.href = "page2.html";
    return;
  }

  // Chat (écrire et envoyer)
  if (e.target.closest(".btn-chat")) {
    // prompt d'écriture (simple)
    const messageText = prompt("Écrire un message :");
    if (!messageText) return;

    // Enregistrer le message dans Firebase (convention: messages/{conversationId} - push)
    const convId = `${currentUser.uid}_${targetUid}`; // simple convention
    const chatRef = ref(db, `messages/${convId}`);
    await push(chatRef, {
      text: messageText,
      from: currentUser.uid,
      to: targetUid,
      timestamp: Date.now()
    });

    // Ajouter notification côté destinataire
    const notifRef = ref(db, `notifications/${targetUid}`);
    await push(notifRef, {
      type: "message",
      from: currentUser.uid,
      text: messageText.slice(0, 120),
      timestamp: Date.now(),
      read: false
    });

    // Créer un mini-profil draggable et le sauvegarder localement
    const imgSrc = card.querySelector("img").src;
    const id = makeId();
    // position initiale: empilé avec offset pour éviter superposition exacte
    const existing = loadLocalMiniProfiles();
    const offset = (existing.length % 6) * 20; // simple offset
    const left = 30 + offset;
    const top = 100 + offset;
    const miniData = { id, uid: targetUid, img: imgSrc, left, top };
    createMiniProfileElement(miniData, true);

    alert("Message envoyé !");
    return;
  }

  // Like (Mike)
  if (e.target.closest(".btn-like")) {
    // enregistrer le like côté destinataire (pour qu'il voie qui a liké)
    await update(ref(db, `users/${targetUid}/likes/${currentUser.uid}`), true);
    e.target.classList.add("active");

    // notification côté destinataire
    const notifRef = ref(db, `notifications/${targetUid}`);
    await push(notifRef, {
      type: "like",
      from: currentUser.uid,
      text: "Vous avez reçu un like 💖",
      timestamp: Date.now(),
      read: false
    });

    return;
  }

  // Favoris
  if (e.target.closest(".btn-fav")) {
    const favBtn = e.target.closest(".btn-fav");
    // toggle: si déjà dans favoris -> supprimer, sinon ajouter
    const currentUid = auth.currentUser.uid;
    const favRef = ref(db, `users/${currentUid}/favoris/${targetUid}`);

    if (favorisList.includes(targetUid)) {
      // supprimer
      await remove(favRef);
      favBtn.classList.remove("active");
      // mettre à jour local array: favorisList sera mis à jour par onValue watcher
      // supprimer mini-profiles liés
      removeMiniProfilesForUid(targetUid);
      alert("Favori supprimé.");
    } else {
      // ajouter
      await set(favRef, true);
      favBtn.classList.add("active");
      // ajout local se fera via watcher onValue
      alert("Ajouté aux favoris.");
    }
    return;
  }
});

// clic sur mini-profile principal -> page2.html
miniProfilePic.addEventListener("click", () => {
  window.location.href = "page2.html";
});

// Favoris bouton bas -> affiche liste interactive (possibilité de supprimer)
favorisBtn.addEventListener("click", async () => {
  const currentUser = auth.currentUser;
  if (!currentUser) return alert("Utilisateur non connecté.");

  // récupérer favoris depuis Firebase (au cas où watcher n'a pas reçu)
  const favRef = ref(db, `users/${currentUser.uid}/favoris`);
  let favObj = null;
  await new Promise(resolve => {
    onValue(favRef, snap => {
      favObj = snap.exists() ? snap.val() : null;
      resolve();
    }, { onlyOnce: true });
  });

  const favUids = favObj ? Object.keys(favObj) : [];

  if (favUids.length === 0) {
    alert("Aucun favori enregistré !");
    return;
  }

  // Construire un petit menu textuel simple (prompt) ; tu peux remplacer par un modal HTML si tu veux plus tard
  let msg = "Favoris enregistrés :\n";
  favUids.forEach((uid, i) => {
    msg += `${i+1}. ${uid}\n`;
  });
  msg += "\nEntrez le numéro pour supprimer ce favori, ou annuler.";
  const choice = prompt(msg);
  if (!choice) return;
  const idx = parseInt(choice, 10) - 1;
  if (isNaN(idx) || idx < 0 || idx >= favUids.length) {
    alert("Choix invalide.");
    return;
  }
  const toRemoveUid = favUids[idx];
  // supprimer dans Firebase
  await remove(ref(db, `users/${currentUser.uid}/favoris/${toRemoveUid}`));
  // supprimer mini-profiles liés
  removeMiniProfilesForUid(toRemoveUid);
  alert("Favori supprimé et profils mini associés supprimés.");
});

// restaurer mini profiles au chargement
restoreMiniProfiles();
</script>
</body>
</html>
